##  Reading 14: Recursion(递归)

###  目标

今天的课程结束后，你应该：

- 能够将递归问题分解为递归步骤和基本情况
- 知道何时以及如何在递归中使用辅助方法
- 了解递归与迭代的优点和缺点

```latex
生产中不建议大量使用递归，建议通过循环去进行优化。最基本的原因是，节省内存空间。
但是循环改造递归，可读性会降低，建议注释写完备一些。
```

### 经典递归问题

- 斐波那契额数列
- 阶乘

### 递归的本质

```latex
子问题的分解

递归的基本结构
- 基本情况（ddl，无法继续分解，end point 情况）例如：斐波那契数列的两个基本情况：n=0，n=1
- 递归步骤

以下是递归实现可能出错的三种常见方式：
- 基本情况完全缺失，或者问题需要多个基本情况但并未涵盖所有基本情况。
- 递归步骤不会减少到更小的子问题，因此递归不会收敛。
- 可变数据结构的别名会在递归调用中无意间共享和变异。
```

### 辅助变量

全局变量记得设置回原值。

### 什么时候用递归

```
我们已经看到使用递归的两个常见原因：
该问题自然是递归的（例如斐波那契）
数据自然是递归的（例如文件系统）

使用递归应注意以下问题：
递归情况可能无法简化为更小的子问题
缺少基本情况
一些输入导致无限递归
maxList和之间的相互递归maxOfRange导致无限递归
可变对象的别名在递归调用之间共享，并且会发生有害的突变
```

## Reading 15: Equality

### 目标

- 了解等价关系的性质。
- 了解根据抽象函数和观察定义的不可变类型的相等性。
- 区分引用相等和对象相等。
- 区分可变类型的严格观察和行为平等。
- 了解对象契约并能够正确实现可变和不可变类型的相等性。

### 等价关系

```mathematica
在类型 T 上定义的相等运算可以被视为二元关系E ⊆ T x T，其中一对值(x,y) ∈ E 当且仅当根据 E 认为x和y相等。
此外，对于相等运算，E 必须是等价关系，这意味着它是：
reflexive:
(t,t) ∈ E  ∀ t ∈ T
symmetric:
(t,u) ∈ E  ⇒  (u,t) ∈ E
transitive:
(t,u) ∈ E ∧ (u,v) ∈ E  ⇒  (t,v) ∈ E

For ==, the equivalence E is the set of pairs (x,y) for which x == y. So for ==, these properties can also be written as:
对于==，等价E是(x,y)的集合x == y。因此对于==，这些属性也可以写为：
reflexive:
t == t  ∀ t ∈ T
symmetric:
t == u  ⇒  u == t
transitive:
t == u ∧ u == v  ⇒  t == v
```

## == 与 equals()

```
同时重写hashcode() 和 equals() 
```

- 相等应该是等价关系（自反、对称、传递）。
- 等式和哈希码必须彼此一致，这样使用哈希表（如`HashSet`和`HashMap`）的数据结构才能正常工作。
- 抽象函数是不可变数据类型中相等的基础（这意味着不可变类型必须重写`equals()`, 因此`hashCode()`）。
- 引用相等是可变数据类型中相等的基础；这是确保随时间推移的一致性并避免破坏哈希表的表示不变量的唯一方法。